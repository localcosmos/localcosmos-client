/**
 * This file describes the TaxonProfiles files generated by Local cosmos App Kit
 */

import { TaxonProfilesFeature, FeatureBase } from "../types/Features";

import {
  TaxonType,
  TaxonWithImage,
  SearchTaxon,
  TaxonScientificName,
  TaxonWithSlugsAndImages
} from './BackboneTaxonomy';
import { ImageWithTextAndLicence } from '../types/Image';
import { MatrixFilterDataTypes } from './NatureGuide';
import { GenericFormReference } from './GenericForm';
import type { TemplateContentLink } from "../api/TemplateContent";

type StartLetters = {
  taxonLatname: string[],
  vernacular: Record<string, string[]>,
}

export type TaxonProfilesDefinition = FeatureBase & {
  startLetters: StartLetters,
  navigationSlugs: Record<string,string>,
}

export type VernacularNamesDict = Record<string,string>

export type TaxonImageSet = {
  taxonProfileImages: ImageWithTextAndLicence[],
  nodeImages: ImageWithTextAndLicence[],
  taxonImages: ImageWithTextAndLicence[],
}

export type TaxonProfileReference = TaxonType & {
  vernacularNames: VernacularNamesDict,
  alternativeVernacularNames: VernacularNamesDict,
  images: TaxonImageSet
}

/**
 * localcosmos/features/TaxonProfiles/{uuid}/search.json
 */
export type TaxonProfilesSearchIndex = {
  taxonLatname: {
    [startLetter: string]: SearchTaxon[]
  },
  vernacular: {
    [locale: string]: {
      [startLetter: string]: SearchTaxon[]
    }
  }
}

export type TaxonProfilesRegistryEntry = TaxonType & {
  image: ImageWithTextAndLicence | null,
  shortProfile: string |  null,
  nameType: string,
  name: string,
  isPreferredName: boolean,
  acceptedNameUuid: string | null,
  hasTaxonProfile: boolean,
  vernacularNames: VernacularNamesDict,
  slug: string,
  localizedSlug: Record<string, string>,
}

/**
 * localcosmos/features/TaxonProfiles/{uuid}/registry.json
 */
export type TaxonProfilesRegistry = Record<string, TaxonProfilesRegistryEntry>

/**
 * localcosmos/features/TaxonProfiles/vernacular/{locale}.json
 */
export type TaxonProfileList = SearchTaxon[]


/**
 * localcosmos/features/TaxonProfiles/{uuid}/navigation.json
 */
export type TaxonProfilesNavigationNodeChild = {
  key: string,
  parentKey: string,
  name: string,
  verboseName: string,
  taxa: TaxonType[],
  images: ImageWithTextAndLicence[],
  primaryImage: ImageWithTextAndLicence | null,
  slug: string,
}

export type TaxonProfilesNavigationNode = {
  name: string,
  verboseName: string,
  description: string,
  isStartNode: boolean,
  isTerminalNode: boolean,
  images: ImageWithTextAndLicence[],
  imageAnalysis: {
    nodes : { 
      maxImages: number,
      minImages: number,
      modeImages: number,
    },
    taxonProfiles : {
      maxImages: number,
      minImages: number,
      modeImages: number,
    }
  },
  children: TaxonProfilesNavigationNodeChild[],
  taxonProfiles: TaxonWithSlugsAndImages[],
}

export type TaxonProfilesNavigation = Record<string, TaxonProfilesNavigationNode>


/**
 * The below describes the full Taxon Profile, stored in a separate file for each taxon
 * localcosmos/features/TaxonProfiles/{taxon_source}/{nameUuid}.json
 */


// old
export type TraitValue = {
  encodedSpace: string,
  imageUrl: string,
}

export type Trait = {
  matrixFilter: MatrixFilterDataTypes, // MatrixFilter should be removed in the future
  values: TraitValue[],
  hasMoreSpecificOccurrence: boolean,
}

export type TaxonText = {
  taxonTextType: string,
  shortText: string,
  shortTextKey: string,
  longText: string,
  longTextKey: string,
  images: ImageWithTextAndLicence[],
}

export type CategorizedTexts = {
  category: string,
  texts: TaxonText[],
}

export type TaxonRelationshipType = {
  name: string,
  taxonRole: string | null,
  relatedTaxonRole: string | null
}

export type TaxonRelationship = {
  taxon: TaxonWithImage,
  relatedTaxon: TaxonWithImage,
  description: string,
}

export type TypedTaxonRelationships = {
  relationshipType: TaxonRelationshipType,
  relationships: TaxonRelationship[]
}

export enum ExternalMediaType {
    image = 'image',
    youtube = 'youtube',
    mp3 = 'mp3',
    wav = 'wav',
    pdf = 'pdf',
    website = 'website',
    file = 'file',
}

export enum ExternalMediaCategory {
  video = 'video',
  audio = 'audio',
  document = 'document',
}

export type ExternalMedia = {
  mediaCategory: ExternalMediaCategory | null,
  mediaType: ExternalMediaType,
  url: string,
  title: string,
  author: string,
  licence: string | null,
  caption: string | null,
  altText: string | null
}

export type MorphotypeReference = {
  taxonProfileId: number,
  parentTaxonProfileId: number,
  morphotype: string,
  taxon: TaxonWithImage,
  vernacular: {
    [languageCode: string]: string
  },
  image: ImageWithTextAndLicence,
}

export type TaxonProfile = TaxonType & {
  morphotype: string | null,
  vernacular: {
    [locale: string]: string
  },
  allVernacularNames: {
    [locale: string]: string
  },
  slug: string,
  localizedSlug: Record<string, string>,
  nodeNames: string[],
  nodeDecisionRules: any, // todo: unknown
  traits: Trait[],
  shortProfile: string,
  texts: TaxonText[],
  categorizedTexts: CategorizedTexts[],
  images: TaxonImageSet,
  synonyms: TaxonScientificName[],
  gbifNubKey?: number,
  genericForms?: GenericFormReference[],
  taxonRelationships: TypedTaxonRelationships[],
  externalMedia: ExternalMedia[],
  templateContents?: TemplateContentLink[],
  tags: string[],
  seo: {
    title: string,
    metaDescription: string,
  },
  morphotypeProfiles: MorphotypeReference[],
}


export type TaxonLatnameSearchIndex = Record<string, SearchTaxon>
export type VernacularSearchIndex = Record<string, SearchTaxon>

export type SearchIndex = {
  taxonLatname: TaxonLatnameSearchIndex,
  vernacular: Record<string, VernacularSearchIndex>,
}
/**
 * a usable class to query taxonomic profiles
 */
export class TaxonProfiles {

  registry: TaxonProfilesRegistry = {}
  localizedRegistry: SearchTaxon[] = [];
  searchIndex: SearchIndex = {
    taxonLatname: {},
    vernacular: {}
  };

  startLetters: Record<string, string[]> = {
    taxonLatname: [],
    vernacular: []
  }

  navigationSlugs: Record<string, string> = {}

  constructor (private taxonProfilesFeature: TaxonProfilesFeature) {}

  async load (language: string) {
    const url:string = this.taxonProfilesFeature.lookup[this.taxonProfilesFeature.uuid];

    const response = await fetch(url);
    if (response.ok) {
      const taxonProfiles = await response.json() as TaxonProfilesDefinition;
      this.startLetters.taxonLatname = taxonProfiles.startLetters.taxonLatname;
      if (language in taxonProfiles.startLetters.vernacular) {
        this.startLetters.vernacular = taxonProfiles.startLetters.vernacular[language];
      }

      this.navigationSlugs = taxonProfiles.navigationSlugs;
    }
  }

  async loadRegistry () {
    const response = await fetch(this.taxonProfilesFeature.registry);
    if (response.ok) {
      this.registry = await response.json();
    }
  }

  async loadLocalizedRegistry (languageCode: string) {
    const response = await fetch(this.taxonProfilesFeature.localizedRegistries[languageCode]);
    if (response.ok) {
      this.localizedRegistry = await response.json();
    }
  }

  async getNavigationNode(nodeKey: string): Promise<TaxonProfilesNavigationNode|null> {

    const url = `${this.taxonProfilesFeature.navigation}/${nodeKey}.json`;

    let node: TaxonProfilesNavigationNode|null = null;

    const response = await fetch(url);

    if (response.ok) {
      node = await response.json() as TaxonProfilesNavigationNode;

    }

    return node;
  }

  getNodeKeyFromSlug (slug:string): string|null {
    let nodeKey = null;

    if (slug in this.navigationSlugs) {
      nodeKey = this.navigationSlugs[slug];
    }

    return nodeKey
  }

  getRegisteredTaxon (nameUuid: string): TaxonProfilesRegistryEntry | null {
    if (nameUuid in this.registry) {
      return this.registry[nameUuid];
    }
    return null;
  }

  async getTaxonProfile (nameUuid: string): Promise<TaxonProfile | null> {
    if (nameUuid in this.registry) {
      const taxon = this.registry[nameUuid];
      const taxonProfilePath = `${this.taxonProfilesFeature.files}/${taxon.taxonSource}/${taxon.nameUuid}.json`;
      const response = await fetch(taxonProfilePath);
      if (response.ok) {
        try {
          const taxonProfile = await response.json() as TaxonProfile;
          return taxonProfile;
        } catch(e) {
          console.log(e);
        }
      }
    }

    return null;
  }

  async getLocalizedTaxonProfile (nameUuid: string, language:string): Promise<TaxonProfile | null> {
    if (nameUuid in this.registry) {
      const taxon = this.registry[nameUuid];
      const localizedTaxonProfilePath = `${this.taxonProfilesFeature.localizedFiles[language]}/${taxon.taxonSource}/${taxon.nameUuid}.json`;
      const response = await fetch(localizedTaxonProfilePath);
      if (response.ok) {
        try {
          const localizedTaxonProfile = await response.json() as TaxonProfile;
          return localizedTaxonProfile;
        } catch (e) {
          console.log(e);
        }
      }
    }

    return null;
  }

  async getLocalizedMorphotypeProfile (nameUuid: string, morphotype: string, language: string): Promise<TaxonProfile | null> {
    if (nameUuid in this.registry) {
      const taxon = this.registry[nameUuid];
      const localizedMorphotypeProfilePath = `${this.taxonProfilesFeature.localizedMorphotypeFiles[language]}/${taxon.taxonSource}/${taxon.nameUuid}_${morphotype}.json`;
      const response = await fetch(localizedMorphotypeProfilePath);
      if (response.ok) {
        try {
          const localizedMorphotypeProfile = await response.json() as TaxonProfile;
          return localizedMorphotypeProfile;
        } catch (e) {
          console.log(e);
        }
      }
    }

    return null;
  }

  getRelatedTaxonProfiles (taxon: TaxonType, limit?: number, minNuidLength?: number): TaxonProfilesRegistryEntry[] {
    const max = limit || 4;
    minNuidLength = minNuidLength || 9;

    const picks: TaxonProfilesRegistryEntry[] = [];
    const includedNameUuids: string[] = [];

    let nuid = taxon.taxonNuid.slice(0, -3);

    while (picks.length < max && nuid) {

      Object.values(this.registry).every((taxonProfile) => {

        if (taxonProfile.taxonSource === taxon.taxonSource && taxonProfile.taxonNuid.startsWith(nuid) && !includedNameUuids.includes(taxonProfile.nameUuid) && taxonProfile.nameUuid !== taxon.nameUuid) {
          picks.push(taxonProfile);
          includedNameUuids.push(taxonProfile.nameUuid);
        }

        if (picks.length < max) {
          return true;
        }
        return false;

      });
      
      nuid = nuid.slice(0, -3);

      if (nuid.length < minNuidLength) {
        break;
      }
      
    }

    return picks;
  }

  getRandomTaxonProfiles (limit?: number, noLatnames?: boolean): SearchTaxon[] {
    limit = limit || 4;

    const picks: SearchTaxon[] = [];
    const pickedUuids: string[] = [];
      
    const min = 0;
    const max = this.localizedRegistry.length - 1;

    if (limit > max) {
      limit = max;
    }

    let tried:number = 0;

    while (picks.length < limit && tried < max) {
      const index = Math.floor(Math.random() * (max - min + 1) + min);
      const candidate: SearchTaxon = this.localizedRegistry[index];

      tried++;
      if (candidate.image && pickedUuids.indexOf(candidate.nameUuid) === -1) {     
        if (noLatnames === true && candidate.name !== candidate.taxonLatname){
          picks.push(candidate);
          pickedUuids.push(candidate.nameUuid);
        } else if (noLatnames !== true) {
          picks.push(candidate);
          pickedUuids.push(candidate.nameUuid);
        }
        
      }
    }
    return picks;

  }

  search (searchText: string, limit?: number): SearchTaxon[] {
    searchText = searchText.toLowerCase();

    // words as a list
    const words = searchText.split(' ').filter( (word) => word.length > 0 );

    const matches: SearchTaxon[] = [];
    const foundNameUuids: string[] = [];

    this.localizedRegistry.every((taxonProfile) => {

      const latnameLower = taxonProfile.taxonLatname.toLowerCase();
      const nameLower = taxonProfile.name.toLowerCase();

      const latnameWords = latnameLower.split(' ').filter( (word) => word.length > 0 );

      // startswith should be on top, includes after
      if ( ( latnameLower.startsWith(searchText) || nameLower.startsWith(searchText) ) && !foundNameUuids.includes(taxonProfile.nameUuid)) {
        // insert at 0 to prioritize startswith matches
        matches.unshift(taxonProfile)
        foundNameUuids.push(taxonProfile.nameUuid)
      }
      else if ( ( latnameLower.includes(searchText) || nameLower.includes(searchText) ) && !foundNameUuids.includes(taxonProfile.nameUuid)) {
        matches.push(taxonProfile)
        foundNameUuids.push(taxonProfile.nameUuid)
      }

      // for example, allow the searchtext  "tur mer" to find "turdus merula"
      if (words.length == 2) {
        const firstWord = words[0];
        const secondWord = words[1];

        const firstWordMatches = latnameWords.some( (word) => word.startsWith(firstWord) );
        const secondWordMatches = latnameWords.some( (word) => word.startsWith(secondWord) );

        if ( firstWordMatches && secondWordMatches && !foundNameUuids.includes(taxonProfile.nameUuid) ) {
          matches.push(taxonProfile)
          foundNameUuids.push(taxonProfile.nameUuid)
        }
      }

      if (limit && matches.length >= limit) {
        return false;
      }

      return true;

    });

    return matches;
  }

  searchVernacular (searchText: string, limit?: number | null, startsWithOnly?: boolean ): SearchTaxon[] {
    searchText = searchText.toLowerCase();
    const matches: SearchTaxon[] = [];
    const foundNameUuids: string[] = [];

    this.localizedRegistry.every((taxonProfile) => {

      const nameLower = taxonProfile.name.toLowerCase();

      if (startsWithOnly === true) {
        if ( nameLower.startsWith(searchText) && !foundNameUuids.includes(taxonProfile.nameUuid)) {
          matches.push(taxonProfile)
          foundNameUuids.push(taxonProfile.nameUuid)
        }
      } else {
        if ( nameLower.includes(searchText) && !foundNameUuids.includes(taxonProfile.nameUuid)) {
          matches.push(taxonProfile)
          foundNameUuids.push(taxonProfile.nameUuid)
        }
      }

      if (limit && matches.length >= limit) {
        return false;
      }

      return true;

    });

    return matches;
  }

}