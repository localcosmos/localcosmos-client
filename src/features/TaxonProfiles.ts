/**
 * This file describes the TaxonProfiles files generated by Local cosmos App Kit
 */

 import { TaxonProfilesFeature } from "../types/Features";

import {
  TaxonType,
  LatnameSearchTaxon,
  VernacularSearchTaxon,
  TaxonScientificName
} from './BackboneTaxonomy';
import { ImageWithTextAndLicence } from '../types/Image';
import { MatrixFilter } from './NatureGuide';
import { GenericFormReference } from './GenericForm';


export type VernacularNamesDict = Record<string,string>

export type TaxonImageSet = {
  taxonProfileImages: ImageWithTextAndLicence[],
  nodeImages: ImageWithTextAndLicence[],
  taxonImages: ImageWithTextAndLicence[],
}

export type TaxonProfileReference = TaxonType & {
  vernacularNames: VernacularNamesDict,
  alternativeVernacularNames: VernacularNamesDict,
  images: TaxonImageSet
}

/**
 * localcosmos/features/TaxonProfiles/{uuid}/search.json
 */
export type TaxonProfilesSearchIndex = {
  taxonLatname: {
    [startLetter: string]: LatnameSearchTaxon[]
  },
  vernacular: {
    [locale: string]: {
      [startLetter: string]: VernacularSearchTaxon[]
    }
  }
}

/**
 * localcosmos/features/TaxonProfiles/{uuid}/registry.json
 */
export type TaxonProfilesRegistry = Record<string, TaxonProfileReference>

/**
 * localcosmos/features/TaxonProfiles/vernacular/{locale}.json
 */
export type TaxonProfileList = VernacularSearchTaxon[]



/**
 * The below describes the full Taxon Profile, stored in a separate file for each taxon
 * localcosmos/features/TaxonProfiles/{taxon_source}/{nameUuid}.json
 */


// old
export type TraitValue = {
  encodedSpace: string,
  imageUrl: string,
}

export type Trait = {
  matrixFilter: MatrixFilter,
  values: TraitValue[],
  hasMoreSpecificOccurrence: boolean,
}

export type TaxonText = {
  taxonTextType: string,
  shortText: string,
  shortTextKey: string,
  longText: string,
  longTextKey: string,
}

export type TaxonProfile = TaxonType & {
  vernacular: {
    [locale: string]: string
  },
  allVernacularNames: {
    [locale: string]: string
  },
  nodeNames: string[],
  nodeDecisionRules: any, // todo: unknown
  traits: Trait[],
  texts: TaxonText[],
  images: TaxonImageSet,
  synonyms: TaxonScientificName[],
  gbifNubKey?: number,
  genericForms?: GenericFormReference[],
  templateContents?: object[],
  tags: string[],
}

/**
 * a usable class to query taxonomic profiles
 */
export class TaxonProfiles {

  registry: TaxonProfilesRegistry = {}
  localizedRegistry: VernacularSearchTaxon[] = [];

  constructor (private taxonProfilesFeature: TaxonProfilesFeature) {}

  async loadRegistry () {
    const response = await fetch(this.taxonProfilesFeature.registry);
    this.registry = await response.json();
  }

  async loadLocalizedRegistry (languageCode: string) {
    const response = await fetch(this.taxonProfilesFeature.localizedRegistries[languageCode]);
    if (response.ok) {
      this.localizedRegistry = await response.json();
    }
  }

  getRegisteredTaxon (nameUuid: string): TaxonProfileReference | null {
    if (nameUuid in this.registry) {
      return this.registry[nameUuid];
    }
    return null;
  }

  async getTaxonProfile (nameUuid: string): Promise<TaxonProfile | null> {
    if (nameUuid in this.registry) {
      const taxon = this.registry[nameUuid];
      const taxonProfilePath = `${this.taxonProfilesFeature.files}/${taxon.taxonSource}/${taxon.nameUuid}.json`;
      const response = await fetch(taxonProfilePath);
      if (response.ok) {
        const taxonProfile = await response.json() as TaxonProfile;
        return taxonProfile;
      }
    }

    return null;
  }

  getRelatedTaxonProfiles (taxon: TaxonType, limit?: number, minNuidLength?: number): TaxonProfileReference[] {
    const max = limit || 4;
    minNuidLength = minNuidLength || 9;

    const picks: TaxonProfileReference[] = [];
    const includedNameUuids: string[] = [];

    let nuid = taxon.taxonNuid.slice(0, -3);

    while (picks.length < max && nuid) {

      Object.values(this.registry).every((taxonProfile) => {

        if (taxonProfile.taxonNuid.startsWith(nuid) && !includedNameUuids.includes(taxonProfile.nameUuid) && taxonProfile.nameUuid !== taxon.nameUuid) {
          picks.push(taxonProfile);
          includedNameUuids.push(taxonProfile.nameUuid);
        }

        if (picks.length < max) {
          return true;
        }
        return false;

      });
      
      nuid = nuid.slice(0, -3);

      if (nuid.length < minNuidLength) {
        break;
      }
      
    }

    return picks;
  }

  getRandomTaxonProfiles (limit?: number, noLatnames?: boolean): VernacularSearchTaxon[] {
    limit = limit || 4;

    const picks: VernacularSearchTaxon[] = [];
    const pickedUuids: string[] = [];
      
    const min = 0;
    const max = this.localizedRegistry.length - 1;

    while (picks.length < limit) {
      const index = Math.floor(Math.random() * (max - min + 1) + min);
      const candidate: VernacularSearchTaxon = this.localizedRegistry[index];
      if (candidate.imageUrl && pickedUuids.indexOf(candidate.nameUuid) === -1) {     
        if (noLatnames === true && candidate.name !== candidate.taxonLatname){
          picks.push(candidate);
          pickedUuids.push(candidate.nameUuid);
        } else if (noLatnames !== true) {
          picks.push(candidate);
          pickedUuids.push(candidate.nameUuid);
        }
        
      }
    }
    return picks;

  }

  search (searchText: string, limit?: number): VernacularSearchTaxon[] {
    searchText = searchText.toLowerCase();
    const matches: VernacularSearchTaxon[] = [];
    const foundNameUuids: string[] = [];

    this.localizedRegistry.every((taxonProfile) => {

      const latnameLower = taxonProfile.taxonLatname.toLowerCase();
      const nameLower = taxonProfile.name.toLowerCase();

      if ( ( latnameLower.startsWith(searchText) || nameLower.includes(searchText) ) && !foundNameUuids.includes(taxonProfile.nameUuid)) {
        matches.push(taxonProfile)
        foundNameUuids.push(taxonProfile.nameUuid)
      }

      if (limit && matches.length >= limit) {
        return false;
      }

      return true;

    });

    return matches;
  }

}