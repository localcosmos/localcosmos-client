/**
 * This file describes the TaxonProfiles files generated by Local cosmos App Kit
 */

 import { TaxonProfilesFeature, FeatureBase } from "../types/Features";

import {
  TaxonType,
  SearchTaxon,
  TaxonScientificName,
  TaxonWithSlugsAndImages
} from './BackboneTaxonomy';
import { ImageWithTextAndLicence } from '../types/Image';
import { MatrixFilter } from './NatureGuide';
import { GenericFormReference } from './GenericForm';

type StartLetters = {
  taxonLatname: string[],
  vernacular: Record<string, string[]>,
}

export type TaxonProfilesDefinition = FeatureBase & {
  startLetters: StartLetters,
  navigationSlugs: Record<string,string>,
}

export type VernacularNamesDict = Record<string,string>

export type TaxonImageSet = {
  taxonProfileImages: ImageWithTextAndLicence[],
  nodeImages: ImageWithTextAndLicence[],
  taxonImages: ImageWithTextAndLicence[],
}

export type TaxonProfileReference = TaxonType & {
  vernacularNames: VernacularNamesDict,
  alternativeVernacularNames: VernacularNamesDict,
  images: TaxonImageSet
}

/**
 * localcosmos/features/TaxonProfiles/{uuid}/search.json
 */
export type TaxonProfilesSearchIndex = {
  taxonLatname: {
    [startLetter: string]: SearchTaxon[]
  },
  vernacular: {
    [locale: string]: {
      [startLetter: string]: SearchTaxon[]
    }
  }
}

/**
 * localcosmos/features/TaxonProfiles/{uuid}/registry.json
 */
export type TaxonProfilesRegistry = Record<string, TaxonProfileReference>

/**
 * localcosmos/features/TaxonProfiles/vernacular/{locale}.json
 */
export type TaxonProfileList = SearchTaxon[]


/**
 * localcosmos/features/TaxonProfiles/{uuid}/navigation.json
 */
export type TaxonProfilesNavigationNodeChild = {
  key: string,
  parentKey: string,
  name: string,
  verboseName: string,
  taxa: TaxonType[],
  images: ImageWithTextAndLicence[],
  slug: string,
}

export type TaxonProfilesNavigationNode = {
  name: string,
  verboseName: string,
  description: string,
  isStartNode: boolean,
  isTerminalNode: boolean,
  images: ImageWithTextAndLicence[],
  children: TaxonProfilesNavigationNodeChild[],
  taxonProfiles: TaxonWithSlugsAndImages[],
}

export type TaxonProfilesNavigation = Record<string, TaxonProfilesNavigationNode>


/**
 * The below describes the full Taxon Profile, stored in a separate file for each taxon
 * localcosmos/features/TaxonProfiles/{taxon_source}/{nameUuid}.json
 */


// old
export type TraitValue = {
  encodedSpace: string,
  imageUrl: string,
}

export type Trait = {
  matrixFilter: MatrixFilter,
  values: TraitValue[],
  hasMoreSpecificOccurrence: boolean,
}

export type TaxonText = {
  taxonTextType: string,
  shortText: string,
  shortTextKey: string,
  longText: string,
  longTextKey: string,
}

export type TaxonProfile = TaxonType & {
  vernacular: {
    [locale: string]: string
  },
  allVernacularNames: {
    [locale: string]: string
  },
  nodeNames: string[],
  nodeDecisionRules: any, // todo: unknown
  traits: Trait[],
  texts: TaxonText[],
  images: TaxonImageSet,
  synonyms: TaxonScientificName[],
  gbifNubKey?: number,
  genericForms?: GenericFormReference[],
  templateContents?: object[],
  tags: string[],
}


export type TaxonLatnameSearchIndex = Record<string, SearchTaxon>
export type VernacularSearchIndex = Record<string, SearchTaxon>

export type SearchIndex = {
  taxonLatname: TaxonLatnameSearchIndex,
  vernacular: Record<string, VernacularSearchIndex>,
}
/**
 * a usable class to query taxonomic profiles
 */
export class TaxonProfiles {

  registry: TaxonProfilesRegistry = {}
  localizedRegistry: SearchTaxon[] = [];
  searchIndex: SearchIndex = {
    taxonLatname: {},
    vernacular: {}
  };

  startLetters: Record<string, string[]> = {
    taxonLatname: [],
    vernacular: []
  }

  navigationSlugs: Record<string, string> = {}

  constructor (private taxonProfilesFeature: TaxonProfilesFeature) {}

  async load (language: string) {
    const url:string = this.taxonProfilesFeature.lookup[this.taxonProfilesFeature.uuid];

    const response = await fetch(url);
    if (response.ok) {
      const taxonProfiles = await response.json() as TaxonProfilesDefinition;
      this.startLetters.taxonLatname = taxonProfiles.startLetters.taxonLatname;
      if (language in taxonProfiles.startLetters.vernacular) {
        this.startLetters.vernacular = taxonProfiles.startLetters.vernacular[language];
      }

      this.navigationSlugs = taxonProfiles.navigationSlugs;
      console.log(this.navigationSlugs)

    }
  }

  async loadRegistry () {
    const response = await fetch(this.taxonProfilesFeature.registry);
    if (response.ok) {
      this.registry = await response.json();
    }
  }

  async loadLocalizedRegistry (languageCode: string) {
    const response = await fetch(this.taxonProfilesFeature.localizedRegistries[languageCode]);
    if (response.ok) {
      this.localizedRegistry = await response.json();
    }
  }

  async getNavigationNode(nodeKey: string): Promise<TaxonProfilesNavigationNode|null> {
    const url = this.taxonProfilesFeature.navigation;

    let node: TaxonProfilesNavigationNode|null = null;

    const response = await fetch(url);

    if (response.ok) {

      const navigation = await response.json() as TaxonProfilesNavigation;

      if (nodeKey in navigation) {
        node = navigation[nodeKey];
      }
      
    }

    return node;
  }

  getNodeKeyFromSlug (slug:string): string|null {
    let nodeKey = null;

    if (slug in this.navigationSlugs) {
      nodeKey = this.navigationSlugs[slug];
    }

    return nodeKey
  }

  getRegisteredTaxon (nameUuid: string): TaxonProfileReference | null {
    if (nameUuid in this.registry) {
      return this.registry[nameUuid];
    }
    return null;
  }

  async getTaxonProfile (nameUuid: string): Promise<TaxonProfile | null> {
    if (nameUuid in this.registry) {
      const taxon = this.registry[nameUuid];
      const taxonProfilePath = `${this.taxonProfilesFeature.files}/${taxon.taxonSource}/${taxon.nameUuid}.json`;
      const response = await fetch(taxonProfilePath);
      if (response.ok) {
        try {
          const taxonProfile = await response.json() as TaxonProfile;
          return taxonProfile;
        } catch(e) {
          console.log(e);
        }
      }
    }

    return null;
  }

  async getLocalizedTaxonProfile (nameUuid: string, language:string): Promise<TaxonProfile | null> {
    if (nameUuid in this.registry) {
      const taxon = this.registry[nameUuid];
      const localizedTaxonProfilePath = `${this.taxonProfilesFeature.localizedFiles[language]}/${taxon.taxonSource}/${taxon.nameUuid}.json`;
      const response = await fetch(localizedTaxonProfilePath);
      if (response.ok) {
        try {
          const localizedTaxonProfile = await response.json() as TaxonProfile;
          return localizedTaxonProfile;
        } catch (e) {
          console.log(e);
        }
      }
    }

    return null;
  }

  getRelatedTaxonProfiles (taxon: TaxonType, limit?: number, minNuidLength?: number): TaxonProfileReference[] {
    const max = limit || 4;
    minNuidLength = minNuidLength || 9;

    const picks: TaxonProfileReference[] = [];
    const includedNameUuids: string[] = [];

    let nuid = taxon.taxonNuid.slice(0, -3);

    while (picks.length < max && nuid) {

      Object.values(this.registry).every((taxonProfile) => {

        if (taxonProfile.taxonSource === taxon.taxonSource && taxonProfile.taxonNuid.startsWith(nuid) && !includedNameUuids.includes(taxonProfile.nameUuid) && taxonProfile.nameUuid !== taxon.nameUuid) {
          picks.push(taxonProfile);
          includedNameUuids.push(taxonProfile.nameUuid);
        }

        if (picks.length < max) {
          return true;
        }
        return false;

      });
      
      nuid = nuid.slice(0, -3);

      if (nuid.length < minNuidLength) {
        break;
      }
      
    }

    return picks;
  }

  getRandomTaxonProfiles (limit?: number, noLatnames?: boolean): SearchTaxon[] {
    limit = limit || 4;

    const picks: SearchTaxon[] = [];
    const pickedUuids: string[] = [];
      
    const min = 0;
    const max = this.localizedRegistry.length - 1;

    if (limit > max) {
      limit = max;
    }

    let tried:number = 0;

    while (picks.length < limit && tried < max) {
      const index = Math.floor(Math.random() * (max - min + 1) + min);
      const candidate: SearchTaxon = this.localizedRegistry[index];

      tried++;
      if (candidate.image && pickedUuids.indexOf(candidate.nameUuid) === -1) {     
        if (noLatnames === true && candidate.name !== candidate.taxonLatname){
          picks.push(candidate);
          pickedUuids.push(candidate.nameUuid);
        } else if (noLatnames !== true) {
          picks.push(candidate);
          pickedUuids.push(candidate.nameUuid);
        }
        
      }
    }
    return picks;

  }

  search (searchText: string, limit?: number): SearchTaxon[] {
    searchText = searchText.toLowerCase();
    const matches: SearchTaxon[] = [];
    const foundNameUuids: string[] = [];

    this.localizedRegistry.every((taxonProfile) => {

      const latnameLower = taxonProfile.taxonLatname.toLowerCase();
      const nameLower = taxonProfile.name.toLowerCase();

      if ( ( latnameLower.startsWith(searchText) || nameLower.includes(searchText) ) && !foundNameUuids.includes(taxonProfile.nameUuid)) {
        matches.push(taxonProfile)
        foundNameUuids.push(taxonProfile.nameUuid)
      }

      if (limit && matches.length >= limit) {
        return false;
      }

      return true;

    });

    return matches;
  }

  searchVernacular (searchText: string, limit?: number | null, startsWithOnly?: boolean ): SearchTaxon[] {
    searchText = searchText.toLowerCase();
    const matches: SearchTaxon[] = [];
    const foundNameUuids: string[] = [];

    this.localizedRegistry.every((taxonProfile) => {

      const nameLower = taxonProfile.name.toLowerCase();

      if (startsWithOnly === true) {
        if ( nameLower.startsWith(searchText) && !foundNameUuids.includes(taxonProfile.nameUuid)) {
          matches.push(taxonProfile)
          foundNameUuids.push(taxonProfile.nameUuid)
        }
      } else {
        if ( nameLower.includes(searchText) && !foundNameUuids.includes(taxonProfile.nameUuid)) {
          matches.push(taxonProfile)
          foundNameUuids.push(taxonProfile.nameUuid)
        }
      }

      if (limit && matches.length >= limit) {
        return false;
      }

      return true;

    });

    return matches;
  }

}