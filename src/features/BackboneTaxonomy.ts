/**
 * This file describes taxonmic concepts and all generated contents of BackboneTaxonomy/<uuid>/ as generated by Local Cosmos App Kit
 */
import { BackboneTaxonomyFeature } from "../types/Features";
import type { ImageUrls, ImageWithTextAndLicence } from "../types/Image";

/**
 * Taxonomic Concepts
 */
// a scientific name is only complete if it contains the author
export type TaxonScientificName = {
  taxonLatname: string,
  taxonAuthor: string,
}

export type TaxonType = TaxonScientificName & {
  taxonSource: string,
  nameUuid: string,
  taxonNuid: string,
}

export type VernacularTaxonType = TaxonType & {
  name: string
}

export enum RestrictionType {
  exists = 'exists',
  required = 'required',
  optional = 'optional',
}

export type TaxonomicRestriction = TaxonType & {
  restrictionType: RestrictionType,
}


export type BackboneTaxon = TaxonType & {
  image: ImageWithTextAndLicence,
  gbifNubKey?: number,
}

export type TaxonWithImage = TaxonType & {
  gbifNubKey?: number,
  image: ImageWithTextAndLicence,
}

export type TaxonWithImages = TaxonType & {
  gbifNubKey?: number,
  images: ImageWithTextAndLicence[],
}

export type TaxonWithSlugsAndImages = TaxonWithImages & {
  slug: string,
  localizedSlugs: Record<string, string>,
}

export type SearchTaxon = BackboneTaxon & {
  name: string,
  nameType: string,
  isPreferredName: boolean,
  acceptedNameUuid: string,
  hasTaxonProfile: boolean,
}
/**
 * localcosmos/features/BackboneTaxonomy/vernacular/{language_code}.json
 */
export type SearchTaxonList = SearchTaxon[];


/**
 * localcosmos/features/BackboneTaxonomy/vernacular/{language_code}_lookup.json
 */
export type VernacularLookupEntry = {
  primary: string,
  secondary: string[]
}
export type VernacularNamesLookup = {
  [nameUuid: string] : VernacularLookupEntry
};

/**
 * localcosmos/features/BackboneTaxonomy/alphabet/{letters}.json
 */
export type TaxonLatnamesList = BackboneTaxon[];

export class BackboneTaxonomy {

  currentLanguage: string | null;
  loadedLanguageCode: string | null = null
  vernacularNamesForSearch: SearchTaxonList = []
  vernacularNamesLookup: VernacularNamesLookup = {}

  currentStartLetters: string | null = null
  currentLatnamesForSearch:  TaxonLatnamesList = []

  slugs: Record<string, string> = {}
  localizedSlugs: Record<string, string> = {}

  maxResults: number = 10;

  constructor(private backboneTaxonomyFeature: BackboneTaxonomyFeature) {
    this.currentLanguage = null;
  }

  async loadLanguage(languageCode:string) {
    await this.loadVernacularFiles(languageCode);
    this.loadedLanguageCode = languageCode;
  }

  async loadLatnameFile(startLetters: string) {
    const latnamesPath = `${this.backboneTaxonomyFeature.alphabet}/${startLetters}.json`;
    const response = await fetch(latnamesPath);
    if (response.ok) {
      try {
        this.currentLatnamesForSearch = await response.json();
      }
      catch (e) {
        console.log(e);
      }
    } else {
      this.currentLatnamesForSearch = [];
    }
  }

  async loadVernacularFiles(languageCode: string) {
    if (this.loadedLanguageCode !== languageCode) {
      this.vernacularNamesForSearch = [];
      this.vernacularNamesLookup = {};
      this.loadedLanguageCode = null;

      if (languageCode in this.backboneTaxonomyFeature.vernacular) {
        const vernacularPath = this.backboneTaxonomyFeature.vernacular[languageCode];
        const response = await fetch(vernacularPath);
        if (response.ok) {
          this.vernacularNamesForSearch = await response.json();
        }
        else {
          throw new Error(`Invalid BackboneTaxonomy vernacular path ${vernacularPath}`);
        }
      }

      if (languageCode in this.backboneTaxonomyFeature.vernacularLookup) {
        
        const vernacularLookupPath = this.backboneTaxonomyFeature.vernacularLookup[languageCode];
        const response = await fetch(vernacularLookupPath);
        if (response.ok) {
          this.vernacularNamesLookup = await response.json();
        }
        else {
          throw new Error(`Invalid BackboneTaxonomy vernacular path ${vernacularLookupPath}`);
        }
      }
    }
  }

  async loadSlugs(languageCode: string) {
    const taxonLatnameSlugsFilepath = this.backboneTaxonomyFeature.slugs;
    const response = await fetch(taxonLatnameSlugsFilepath);
    if (response.ok) {
      this.slugs = await response.json();
    }

    if (languageCode in this.backboneTaxonomyFeature.localizedSlugs) {
      const localizedSlugsPath = this.backboneTaxonomyFeature.localizedSlugs[languageCode];
      const response = await fetch(localizedSlugsPath);
      if (response.ok) {
        this.localizedSlugs = await response.json();
      }
    }

  }

  getTaxon (nameUuid:string) {

  }

  async searchLatnames(searchText: string): Promise<SearchTaxonList> {
    searchText = searchText.toLocaleLowerCase();

    const results:SearchTaxonList = [];
    let resultCount = 0;

    if (searchText.length >= 2) {
      const startLetters = searchText.substring(0,2).toUpperCase();
      if (startLetters != this.currentStartLetters) {
        await this.loadLatnameFile(startLetters);
      }
    }

    if (searchText.length >=3) {
      this.currentLatnamesForSearch.every((taxon) => {

        const taxonLatname = taxon.taxonLatname.toLowerCase();
  
        if (taxonLatname === searchText) {

          const result = JSON.parse(JSON.stringify(taxon));
          result.name = null;

          results.unshift(result);
          resultCount++;
        } else if (taxonLatname.indexOf(searchText) === 0) {
          const result = JSON.parse(JSON.stringify(taxon));
          result.name = null;
          results.push(result);
          resultCount++;
        }
  
        if (resultCount >= this.maxResults) {
          return false;
        }
        return true;
      });
    }

    return results;
  }

  searchVernacularNames(searchText: string): SearchTaxonList {
    searchText = searchText.toLowerCase();

    const results: SearchTaxon[] = [];
    let resultCount = 0;

    this.vernacularNamesForSearch.every((vernacularTaxon) => {

      const vernacularName = vernacularTaxon.name.toLowerCase();

      if (vernacularName === searchText || vernacularName.indexOf(searchText) === 0) {
        results.unshift(vernacularTaxon);
        resultCount++;
      } else if (vernacularName.indexOf(searchText) >= 0) {
        results.push(vernacularTaxon);
        resultCount++;
      }

      if (resultCount >= this.maxResults) {
        return false;
      }
      return true;
    });

    return results;
  }

  async searchTaxon(searchText: string): Promise<SearchTaxonList> {
    const latnames = await this.searchLatnames(searchText);
    const vernacularNames = this.searchVernacularNames(searchText);

    const results = vernacularNames.concat(latnames);
    return results;
  }

  vernacular(nameUuid:string): string {
    let name = '';

    if (nameUuid in this.vernacularNamesLookup) {
      name = this.vernacularNamesLookup[nameUuid].primary;
    }

    return name;

  }

  slugToNameUuid(slug:string): string|null {
    let nameUuid: string|null = null;

    if (slug in this.slugs) {
      nameUuid = this.slugs[slug];
    } else if (slug in this.localizedSlugs) {
      nameUuid = this.localizedSlugs[slug];
    }

    return nameUuid;
  }

}