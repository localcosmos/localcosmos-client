/**
 * This file describes taxonmic concepts and all generated contents of BackboneTaxonomy/<uuid>/ as generated by Local Cosmos App Kit
 */
import { BackboneTaxonomyFeature } from "../types/Features";
import type { ImageUrls, ImageWithTextAndLicence } from "../types/Image";

/**
 * Taxonomic Concepts
 */
// a scientific name is only complete if it contains the author
export type TaxonScientificName = {
  taxonLatname: string,
  taxonAuthor: string,
}

export type TaxonType = TaxonScientificName & {
  taxonSource: string,
  nameUuid: string,
  taxonNuid: string,
}

export type VernacularTaxonType = TaxonType & {
  name: string
}

export enum RestrictionType {
  exists = 'exists',
  required = 'required',
  optional = 'optional',
}

export type TaxonomicRestriction = TaxonType & {
  restrictionType: RestrictionType,
}


export type BackboneTaxon = TaxonType & {
  image: ImageWithTextAndLicence,
  gbifNubKey?: number,
}

export type TaxonWithImage = TaxonType & {
  gbifNubKey?: number,
  image: ImageWithTextAndLicence,
  shortProfile: string,
}

export type TaxonWithImages = TaxonType & {
  gbifNubKey?: number,
  images: ImageWithTextAndLicence[],
  primaryImage: ImageWithTextAndLicence | null,
}

export type TaxonWithSlugsAndImages = TaxonWithImages & {
  slug: string,
  localizedSlugs: Record<string, string>,
}

export type SearchTaxon = BackboneTaxon & {
  name: string,
  nameType: string,
  isPreferredName: boolean,
  acceptedNameUuid: string,
  hasTaxonProfile: boolean,
}
/**
 * localcosmos/features/BackboneTaxonomy/vernacular/{language_code}.json
 */
export type SearchTaxonList = SearchTaxon[];


/**
 * localcosmos/features/BackboneTaxonomy/vernacular/{language_code}_lookup.json
 */
export type VernacularLookupEntry = {
  primary: string,
  secondary: string[]
}
export type VernacularNamesLookup = {
  [nameUuid: string] : VernacularLookupEntry
};

/**
 * localcosmos/features/BackboneTaxonomy/alphabet/{letters}.json
 */
export type TaxonLatnamesList = BackboneTaxon[];

export class BackboneTaxonomy {

  currentLanguage: string
  
  vernacularNamesLookup: VernacularNamesLookup = {}

  private currentLatnameStartLetter: string | null = null;
  private currentVernacularStartLetter: string | null = null;

  currentLatnamesForSearch:  TaxonLatnamesList = []

  currentVernacularNamesForSearch: SearchTaxonList = []

  slugs: Record<string, string> = {}
  localizedSlugs: Record<string, string> = {}

  maxResults: number = 10;

  constructor(private backboneTaxonomyFeature: BackboneTaxonomyFeature, languageCode: string) {
    this.currentLanguage = languageCode;
  }

  setLanguage(languageCode: string) {
    this.currentLanguage = languageCode;
  }

  async loadLatnameFile(startLetter: string) {
    const latnamesPath = `${this.backboneTaxonomyFeature.search.taxonLatname}/${startLetter}.json`;
    try {
      const response = await fetch(latnamesPath);
      if (response.ok) {
        try {
          this.currentLatnamesForSearch = await response.json();
          this.currentLatnameStartLetter = startLetter; // Track latname start letter
        }
        catch (e) {
          console.log(e);
        }
      } else {
        this.currentLatnamesForSearch = [];
      }
    } catch (e) {
      console.error(`Error loading latnames from ${latnamesPath}:`, e);
      this.currentLatnamesForSearch = [];
    }
  }

  async loadVernacularFiles(startLetter: string) {

    this.currentVernacularStartLetter = startLetter; // Track vernacular start letter

    if (this.currentLanguage in this.backboneTaxonomyFeature.search.vernacular) {

      const vernacularNamesPath = `${this.backboneTaxonomyFeature.search.vernacular[this.currentLanguage]}/${startLetter}.json`;
      try {
        const searchFileResponse = await fetch(vernacularNamesPath);
        if (searchFileResponse.ok) {
          try {
            this.currentVernacularNamesForSearch = await searchFileResponse.json();
          }
          catch (e) {
            console.log(e);
          }
        } else {
          this.currentVernacularNamesForSearch = [];
        }
        if (this.currentLanguage in this.backboneTaxonomyFeature.lookup.vernacular) {
          const vernacularLookupPath = this.backboneTaxonomyFeature.lookup.vernacular[this.currentLanguage];
          const response = await fetch(vernacularLookupPath);
          if (response.ok) {
            this.vernacularNamesLookup = await response.json();
          }
          else {
            throw new Error(`Invalid BackboneTaxonomy vernacular path ${vernacularLookupPath}`);
          }
        }
      } catch (e) {
        console.error(`Error loading vernacular names from ${vernacularNamesPath}:`, e);
        this.currentVernacularNamesForSearch = [];
      }
    } else {
      this.currentVernacularNamesForSearch = [];
      this.vernacularNamesLookup = {};
      console.warn(`No vernacular names available for language ${this.currentLanguage} in BackboneTaxonomy feature ${this.backboneTaxonomyFeature.uuid}`);
    }
  }

  async loadSlugs(languageCode: string) {
    const taxonLatnameSlugsFilepath = this.backboneTaxonomyFeature.slugs;
    const response = await fetch(taxonLatnameSlugsFilepath);
    if (response.ok) {
      this.slugs = await response.json();
    }

    if (languageCode in this.backboneTaxonomyFeature.localizedSlugs) {
      const localizedSlugsPath = this.backboneTaxonomyFeature.localizedSlugs[languageCode];
      const response = await fetch(localizedSlugsPath);
      if (response.ok) {
        this.localizedSlugs = await response.json();
      }
    }

  }

  getTaxon (nameUuid:string) {

  }

  async searchLatnames(searchText: string): Promise<SearchTaxonList> {
    searchText = searchText.toLocaleLowerCase();

    const results:SearchTaxonList = [];
    let resultCount = 0;

    if (searchText.length >= 2) {
      const startLetters = searchText.substring(0,1).toUpperCase();
      if (startLetters !== this.currentLatnameStartLetter) { // Use specific tracking
        await this.loadLatnameFile(startLetters);
      }
    }

    if (searchText.length >=3) {
      this.currentLatnamesForSearch.every((taxon) => {

        const taxonLatname = taxon.taxonLatname.toLowerCase();
  
        if (taxonLatname === searchText) {

          const result = JSON.parse(JSON.stringify(taxon));
          result.name = null;

          results.unshift(result);
          resultCount++;
        } else if (taxonLatname.indexOf(searchText) === 0) {
          const result = JSON.parse(JSON.stringify(taxon));
          result.name = null;
          results.push(result);
          resultCount++;
        }
  
        if (resultCount >= this.maxResults) {
          return false;
        }
        return true;
      });
    }

    return results;
  }

  async searchVernacularNames(searchText: string): Promise<SearchTaxonList> {
    searchText = searchText.toLowerCase();

    const results: SearchTaxon[] = [];
    let resultCount = 0;

    if (searchText.length >= 2) {
      const startLetter = searchText.substring(0,1).toUpperCase();
      if (startLetter !== this.currentVernacularStartLetter) { // Use specific tracking
        await this.loadVernacularFiles(startLetter);
      }
    }
    this.currentVernacularNamesForSearch.every((vernacularTaxon) => {

      const vernacularName = vernacularTaxon.name.toLowerCase();

      if (vernacularName === searchText || vernacularName.indexOf(searchText) === 0) {
        results.unshift(vernacularTaxon);
        resultCount++;
      } else if (vernacularName.indexOf(searchText) >= 0) {
        results.push(vernacularTaxon);
        resultCount++;
      }

      if (resultCount >= this.maxResults) {
        return false;
      }
      return true;
    });

    return results;
  }

  async searchTaxon(searchText: string): Promise<SearchTaxonList> {
    const latnames = await this.searchLatnames(searchText);
    const vernacularNames = await this.searchVernacularNames(searchText);
    const results = vernacularNames.concat(latnames);
    return results;
  }

  vernacular(nameUuid:string): string {
    let name = '';

    if (nameUuid in this.vernacularNamesLookup) {
      name = this.vernacularNamesLookup[nameUuid].primary;
    }

    return name;

  }

  slugToNameUuid(slug:string): string|null {
    let nameUuid: string|null = null;

    if (slug in this.slugs) {
      nameUuid = this.slugs[slug];
    } else if (slug in this.localizedSlugs) {
      nameUuid = this.localizedSlugs[slug];
    }

    return nameUuid;
  }

}