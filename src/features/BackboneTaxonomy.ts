/**
 * This file describes taxonmic concepts and all generated contents of BackboneTaxonomy/<uuid>/ as generated by Local Cosmos App Kit
 */
import { BackboneTaxonomyFeature } from "../types/Features";
import type { ImageUrls } from "../types/Image";
import { Taxon } from '../Taxon';

/**
 * Taxonomic Concepts
 */
// a scientific name is only complete if it contains the author
export type TaxonScientificName = {
  taxonLatname: string,
  taxonAuthor: string,
}

export type TaxonType = TaxonScientificName & {
  taxonSource: string,
  nameUuid: string,
  taxonNuid: string,
}

export type VernacularTaxonType = TaxonType & {
  name: string
}

export enum RestrictionType {
  exists = 'exists',
  required = 'required',
  optional = 'optional',
}

export type TaxonomicRestriction = TaxonType & {
  restrictionType: RestrictionType,
}


export type BackboneTaxon = TaxonType & {
  imageUrl: ImageUrls,
  gbifNubKey?: number,
}


export type LatnameSearchTaxon = TaxonType & {
  acceptedNameUuid: string,
  isSynonym: boolean,
}

export type VernacularSearchTaxon = BackboneTaxon & {
  name: string // the vernacular name in the given language
}

/**
 * localcosmos/features/BackboneTaxonomy/vernacular/{language_code}.json
 */
export type VernacularNamesList = VernacularSearchTaxon[];


/**
 * localcosmos/features/BackboneTaxonomy/vernacular/{language_code}_lookup.json
 */
export type VernacularLookupEntry = {
  primary: string,
  secondary: string[]
}
export type VernacularNamesLookup = {
  [nameUuid: string] : VernacularLookupEntry
};

/**
 * localcosmos/features/BackboneTaxonomy/alphabet/{letters}.json
 */
export type TaxonLatnamesList = BackboneTaxon[];

export class BackboneTaxonomy {

  currentLanguage: string | null;
  loadedLanguageCode: string | null = null
  vernacularNamesForSearch: VernacularNamesList = []
  vernacularNamesLookup: VernacularNamesLookup = {}

  currentStartLetters: string | null = null
  currentLatnamesForSearch:  TaxonLatnamesList = []

  maxResults: number = 10;

  constructor(private backboneTaxonomyFeature: BackboneTaxonomyFeature) {
    this.currentLanguage = null;
  }

  async loadLanguage(languageCode:string) {
    await this.loadVernacularFiles(languageCode);
    this.loadedLanguageCode = languageCode;
  }

  async loadLatnameFile(startLetters: string) {
    const latnamesPath = `${this.backboneTaxonomyFeature.alphabet}/${startLetters}.json`;
    const response = await fetch(latnamesPath);
    if (response.ok) {
      try {
        this.currentLatnamesForSearch = await response.json();
      }
      catch (e) {
        console.log(e);
      }
    } else {
      this.currentLatnamesForSearch = [];
    }
  }

  async loadVernacularFiles(languageCode: string) {
    if (this.loadedLanguageCode !== languageCode) {
      this.vernacularNamesForSearch = [];
      this.vernacularNamesLookup = {};
      this.loadedLanguageCode = null;

      if (languageCode in this.backboneTaxonomyFeature.vernacular) {
        const vernacularPath = this.backboneTaxonomyFeature.vernacular[languageCode];
        const response = await fetch(vernacularPath);
        if (response.ok) {
          this.vernacularNamesForSearch = await response.json();
        }
        else {
          throw new Error(`Invalid BackboneTaxonomy vernacular path ${vernacularPath}`);
        }
      }

      if (languageCode in this.backboneTaxonomyFeature.vernacularLookup) {
        
        const vernacularLookupPath = this.backboneTaxonomyFeature.vernacularLookup[languageCode];
        const response = await fetch(vernacularLookupPath);
        if (response.ok) {
          this.vernacularNamesLookup = await response.json();
        }
        else {
          throw new Error(`Invalid BackboneTaxonomy vernacular path ${vernacularLookupPath}`);
        }
      }
    }
  }

  getTaxon (nameUuid:string) {

  }

  async searchLatnames(searchText: string): Promise<VernacularNamesList> {
    searchText = searchText.toLocaleLowerCase();

    const results:VernacularNamesList = [];
    let resultCount = 0;

    if (searchText.length >= 2) {
      const startLetters = searchText.substring(0,2).toUpperCase();
      if (startLetters != this.currentStartLetters) {
        await this.loadLatnameFile(startLetters);
      }
    }

    if (searchText.length >=3) {
      this.currentLatnamesForSearch.every((taxon) => {

        const taxonLatname = taxon.taxonLatname.toLowerCase();
  
        if (taxonLatname === searchText) {

          const result = JSON.parse(JSON.stringify(taxon));
          result.name = null;

          results.unshift(result);
          resultCount++;
        } else if (taxonLatname.indexOf(searchText) === 0) {
          const result = JSON.parse(JSON.stringify(taxon));
          result.name = null;
          results.push(result);
          resultCount++;
        }
  
        if (resultCount >= this.maxResults) {
          return false;
        }
        return true;
      });
    }

    return results;
  }

  searchVernacularNames(searchText: string): VernacularNamesList {
    searchText = searchText.toLowerCase();

    const results: VernacularSearchTaxon[] = [];
    let resultCount = 0;

    this.vernacularNamesForSearch.every((vernacularTaxon) => {

      const vernacularName = vernacularTaxon.name.toLowerCase();

      if (vernacularName === searchText || vernacularName.indexOf(searchText) === 0) {
        results.unshift(vernacularTaxon);
        resultCount++;
      } else if (vernacularName.indexOf(searchText) >= 0) {
        results.push(vernacularTaxon);
        resultCount++;
      }

      if (resultCount >= this.maxResults) {
        return false;
      }
      return true;
    });

    return results;
  }

  async searchTaxon(searchText: string): Promise<VernacularNamesList> {
    const latnames = await this.searchLatnames(searchText);
    const vernacularNames = this.searchVernacularNames(searchText);

    const results = vernacularNames.concat(latnames);
    return results;
  }

  vernacular(nameUuid:string): string {
    let name = '';

    if (nameUuid in this.vernacularNamesLookup) {
      name = this.vernacularNamesLookup[nameUuid].primary;
    }

    return name;

  }
}